import{_ as a,p as e,q as h,a1 as r}from"./framework-96b046e1.js";const d={},i=r('<h2 id="_1-多线程是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_1-多线程是怎么实现的" aria-hidden="true">#</a> 1 多线程是怎么实现的？</h2><p>继承Thread类或实现Runnable接口</p><h2 id="_2-读写锁和互斥锁的区别" tabindex="-1"><a class="header-anchor" href="#_2-读写锁和互斥锁的区别" aria-hidden="true">#</a> 2 读写锁和互斥锁的区别</h2><p>读写锁区分读锁和写锁，上了读锁后仍然可以上读锁，适合多读少写常见。</p><h2 id="_3-进程通信、线程通信方式有哪些" tabindex="-1"><a class="header-anchor" href="#_3-进程通信、线程通信方式有哪些" aria-hidden="true">#</a> 3 进程通信、线程通信方式有哪些？</h2><p>进程通信：共享内存、信号量、消息队列、管道、socket</p><p>线程通信：锁、wait-notify、synchronized</p><h2 id="_4-hashmap是什么样的-怎么保证线程安全" tabindex="-1"><a class="header-anchor" href="#_4-hashmap是什么样的-怎么保证线程安全" aria-hidden="true">#</a> 4 hashmap是什么样的，怎么保证线程安全？</h2><p>hashmap 是散列表，底层用数组实现。保证线程安全可以使用ConcurrentHashMap</p><h2 id="_5-lambda表达式是什么" tabindex="-1"><a class="header-anchor" href="#_5-lambda表达式是什么" aria-hidden="true">#</a> 5 lambda表达式是什么？</h2><p>也可以叫做匿名函数，帮助快速定义函数</p><h2 id="_6-jdk1-7和1-8区别" tabindex="-1"><a class="header-anchor" href="#_6-jdk1-7和1-8区别" aria-hidden="true">#</a> 6 jdk1.7和1.8区别</h2><p>lambda、新的时间日期类、optional判空</p><h2 id="_7-java锁和底层原理" tabindex="-1"><a class="header-anchor" href="#_7-java锁和底层原理" aria-hidden="true">#</a> 7 Java锁和底层原理</h2><p>Java锁常用的有synchronized和ReentrantLock关键字</p><p>synchronized在jvm中有偏向锁、轻量级锁、重量级锁几种状态</p><p>说说锁升级过程：</p><p>线程获取锁时，会先获取对象头线程信息</p><p>如果没有，会把这个信息设置为当前线程id，表示偏向锁</p><p>如果有，会检查是否和自身线程id相同，不相同会尝试把线程id修改为自己的，升级为轻量级锁</p><p>如果修改失败，说明当前存在竞争，可能会升级为重量级锁</p><h2 id="_8-说说-volatile" tabindex="-1"><a class="header-anchor" href="#_8-说说-volatile" aria-hidden="true">#</a> 8 说说 volatile</h2><ul><li>禁止指令重排，有序</li><li>可以绕开java内存模型中线程缓存，操作变量时强制从主内存中读写</li></ul><h2 id="_9-hashmap的底层结构" tabindex="-1"><a class="header-anchor" href="#_9-hashmap的底层结构" aria-hidden="true">#</a> 9 hashmap的底层结构？</h2><p>底层是数组，存储时用散列的方式把key映射到不同的 bucket 中</p><p>如果冲突，会在冲突的位置形成链表，大于等于8时，会把链表转化为红黑树</p><h2 id="_10-什么是-happen-before-原则" tabindex="-1"><a class="header-anchor" href="#_10-什么是-happen-before-原则" aria-hidden="true">#</a> 10 什么是 happen before 原则？</h2><p>happens-before关系的定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li><strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></li></ol>',29),n=[i];function p(s,t){return e(),h("div",null,n)}const c=a(d,[["render",p],["__file","Java.html.vue"]]);export{c as default};
