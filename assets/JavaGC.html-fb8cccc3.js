import{_ as a,p as e,q as t,a1 as n}from"./framework-96b046e1.js";const i={},r=n('<h2 id="_1-java-中内存泄露是啥-什么时候出现内存泄露" tabindex="-1"><a class="header-anchor" href="#_1-java-中内存泄露是啥-什么时候出现内存泄露" aria-hidden="true">#</a> 1 java 中内存泄露是啥，什么时候出现内存泄露？</h2><p>通俗说法：不再会被使用的对象的内存不能被回收，就是内存泄露。</p><p>出现时机：如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露</p><p>例如</p><ul><li>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li><li><strong>各种需要显示关闭的连接，如数据库连接、网络连接和 IO 连接等</strong>。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</li><li><strong>变量不合理的作用域</strong>。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为 null，很有可能导致内存泄漏的发生。</li><li><strong>内部类持有外部类</strong>，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li><li>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露</li></ul><h2 id="_2-minor-gc-如果运行的很频繁-可能是什么原因引起的-minor-gc-如果运行的-很慢-可能是什么原因引起的" tabindex="-1"><a class="header-anchor" href="#_2-minor-gc-如果运行的很频繁-可能是什么原因引起的-minor-gc-如果运行的-很慢-可能是什么原因引起的" aria-hidden="true">#</a> 2 minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的 很慢，可能是什么原因引起的?</h2><p>可能是堆内存太小,年轻代内存消耗快</p><h2 id="_3-说下有那些-gc-算法" tabindex="-1"><a class="header-anchor" href="#_3-说下有那些-gc-算法" aria-hidden="true">#</a> 3 说下有那些 GC 算法</h2><p>标记清除、标记压缩、复制算法、引用计数法</p><h2 id="_4-gc-是什么-为什么要有-gc" tabindex="-1"><a class="header-anchor" href="#_4-gc-是什么-为什么要有-gc" aria-hidden="true">#</a> 4 GC 是什么？为什么要有 GC？</h2><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方， GC 可以自动回收内存，减少内存泄漏。</p>',11),c=[r];function o(s,h){return e(),t("div",null,c)}const d=a(i,[["render",o],["__file","JavaGC.html.vue"]]);export{d as default};
