import{_ as a,p as e,q as r,a1 as h}from"./framework-96b046e1.js";const i={},p=h('<h2 id="_1-为什么重写-equals-还要重写-hashcode" tabindex="-1"><a class="header-anchor" href="#_1-为什么重写-equals-还要重写-hashcode" aria-hidden="true">#</a> 1 为什么重写 equals 还要重写 hashcode？</h2><p>HashMap 进行比较会先调用 hashcode() 方法，如果 hashcode() 不等，直接就判定为不相等，而 hashcode() 默认为内存地址。如果不重写，那么比如我们在修改 hashmap 的时候会创建一个新的 key，而不是去修改。</p><h2 id="_2-说一下-map-的分类和常见情况" tabindex="-1"><a class="header-anchor" href="#_2-说一下-map-的分类和常见情况" aria-hidden="true">#</a> 2 说一下 map 的分类和常见情况</h2><p>Map 接口有四个常见实现类 Hashmap、Hashtable、LinkedHashMap、TreeMap</p><p>Hashmap 根据 key 的 Hashcode 存储数据，允许一条记录的 key 为 null，多线程操作可能会导致数据错误</p><p>Hashtable 不允许 key 为 null，方法使用 synchronized 修饰，一个时刻只允许一个线程</p><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，使用 Iterator 遍历时，先得到的就是先插入的</p><p>TreeMap 是根据 key 排序的 map</p><p>扩展：如何选择，一般选择最快的 hashmap，有多线程需求使用 ConcurrentHashMap，排序就用 TreeMap</p><h2 id="_3-object-若不重写-hashcode-的话-hashcode-如何计算出来的" tabindex="-1"><a class="header-anchor" href="#_3-object-若不重写-hashcode-的话-hashcode-如何计算出来的" aria-hidden="true">#</a> 3 Object 若不重写 hashCode() 的话，hashCode() 如何计算出来的？</h2><p>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的内存地址。</p><h2 id="_4-比较的是什么" tabindex="-1"><a class="header-anchor" href="#_4-比较的是什么" aria-hidden="true">#</a> 4 == 比较的是什么</h2><p>如果是对象，比较的的是内存地址</p><p>如果是基本类型，比较的是值</p><h2 id="_5-若对一个类不重写-它的-equals-方法是如何比较的" tabindex="-1"><a class="header-anchor" href="#_5-若对一个类不重写-它的-equals-方法是如何比较的" aria-hidden="true">#</a> 5 若对一个类不重写，它的 equals() 方法是如何比较的？</h2><p>比较的是对象的地址</p><p>注：Java 自带的类型大多重写了 equals 方法</p><h2 id="_6-java8-新特性" tabindex="-1"><a class="header-anchor" href="#_6-java8-新特性" aria-hidden="true">#</a> 6 Java8 新特性</h2><p>Lambda 表达式：运行把函数作为参数传入</p><p>接口支持 default 默认方法</p><p>Stream API：流式编程</p><p>Date Time API：加强时间处理</p><p>Optional 类：解决空指针异常</p><h2 id="_7-说说-lamda-表达式的优缺点" tabindex="-1"><a class="header-anchor" href="#_7-说说-lamda-表达式的优缺点" aria-hidden="true">#</a> 7 说说 Lamda 表达式的优缺点</h2><p>优点：1. 简洁。2. 非常容易并行计算。（默认使用 ForkJoinPool）</p><p>缺点：1.不使用并行计算时，比 for 循环慢。2.调试困难。</p><h2 id="_8-为啥有时会出现-4-0-3-6-0-40000001-这种现象" tabindex="-1"><a class="header-anchor" href="#_8-为啥有时会出现-4-0-3-6-0-40000001-这种现象" aria-hidden="true">#</a> 8 为啥有时会出现 4.0-3.6=0.40000001 这种现象？</h2><p>2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</p><p>如果要精确计算，需要使用 BigDecimal 之类的类</p><h2 id="_9-java-支持的数据类型有哪些-什么是自动拆装箱" tabindex="-1"><a class="header-anchor" href="#_9-java-支持的数据类型有哪些-什么是自动拆装箱" aria-hidden="true">#</a> 9 Java 支持的数据类型有哪些？什么是自动拆装箱？</h2><p>Java 语言支持的 8 种基本数据类型是：</p><ul><li><p>boolean (取决于虚拟机)</p></li><li><p>byte 8</p></li><li><p>char 16</p></li><li><p>short 16</p></li><li><p>int 32</p></li><li><p>float 32</p></li><li><p>long 64</p></li><li><p>double 64</p></li></ul><p>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如： 把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。</p><h2 id="_11-什么是值传递和引用传递" tabindex="-1"><a class="header-anchor" href="#_11-什么是值传递和引用传递" aria-hidden="true">#</a> 11 什么是值传递和引用传递？</h2><p>值传递传的是变量副本，引用传递传入的是变量地址。</p><p>一般认为 Java 都是值传递，但如果传入的是对象，值为地址，因此会修改到原内容</p><h2 id="_12-数组-array-和列表-arraylist-有什么区别-什么时候应该使用-array-而不是-arraylist" tabindex="-1"><a class="header-anchor" href="#_12-数组-array-和列表-arraylist-有什么区别-什么时候应该使用-array-而不是-arraylist" aria-hidden="true">#</a> 12 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h2><p>Array 和 ArrayList 的不同点： Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p><p>Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p><p>处理固定大小的基本类型时，优先使用 Array</p><h2 id="_13-string-和-stringbuffer-的区别" tabindex="-1"><a class="header-anchor" href="#_13-string-和-stringbuffer-的区别" aria-hidden="true">#</a> 13 String 和 StringBuffer 的区别</h2><p>String 类被 final 修饰，不可修改。</p><p>StringBuffer 可以修改。</p><h2 id="_14-int-和-integer-有什么区别" tabindex="-1"><a class="header-anchor" href="#_14-int-和-integer-有什么区别" aria-hidden="true">#</a> 14 int 和 Integer 有什么区别？</h2><p>int 为基本类型，Integer 为包装类型。</p><p>基本类型不需要在堆上分配内存，效率更高、</p><h2 id="_15-和-的区别" tabindex="-1"><a class="header-anchor" href="#_15-和-的区别" aria-hidden="true">#</a> 15 &amp;和&amp;&amp;的区别？</h2><p>&amp; 是按位与，&amp;&amp; 是逻辑与</p><h2 id="_16-在-java-中-如何跳出当前的多重嵌套循环" tabindex="-1"><a class="header-anchor" href="#_16-在-java-中-如何跳出当前的多重嵌套循环" aria-hidden="true">#</a> 16 在 Java 中，如何跳出当前的多重嵌套循环？</h2><p>使用 label 标记 for 循环，break 时带上 label</p><h2 id="_17-简述正则表达式及其用途。" tabindex="-1"><a class="header-anchor" href="#_17-简述正则表达式及其用途。" aria-hidden="true">#</a> 17 简述正则表达式及其用途。</h2><p>正则表达式是描述符合特定规则字符串的工具，记录文本规则。</p><p>常用于匹配和处理文本。</p><h2 id="_18-string-为啥不可变" tabindex="-1"><a class="header-anchor" href="#_18-string-为啥不可变" aria-hidden="true">#</a> 18 String 为啥不可变</h2><p>String 被 final 关键字修饰，内部 value 字节数组也被 final 修饰。</p><p>让 String 不可变可以保证同一字符串被多线程共享，提供缓存效率，减少安全问题。</p>',56),d=[p];function t(n,s){return e(),r("div",null,d)}const c=a(i,[["render",t],["__file","Java基础.html.vue"]]);export{c as default};
