import{_ as a,p as e,q as r,a1 as i}from"./framework-96b046e1.js";const o="/interview/assets/image-20210709103716083-9ee46e3e.png",p="/interview/assets/image-20210709104513251-42f1876b.png",t={},d=i('<h2 id="_1-jvm-回收算法和回收器-cms-采用哪种回收算法-怎么解决内存碎片问题" tabindex="-1"><a class="header-anchor" href="#_1-jvm-回收算法和回收器-cms-采用哪种回收算法-怎么解决内存碎片问题" aria-hidden="true">#</a> 1 JVM 回收算法和回收器，CMS 采用哪种回收算法，怎么解决内存碎片问题?</h2><h3 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h3><p>标记清除算法：标记阶段和清除阶段。</p><p>标记阶段：从根节点（静态代码块变量等，类变量）出发标记所有引用对象，未被标记的就是垃圾对象。</p><p>清除阶段：回收垃圾，回收阶段可能会存在大量空间碎片问题</p><p>复制算法：将内存区域分为两块，每次只使用一块。回收时，把存活对象复制到另一块内存区域，清除本区域对象。</p><p>标记整理算法：比复制算法更适合老年代，老年代存活对象多，复制成本高。标记整理算法是标记所有引用对象，把存活对象压缩移动到内存的一端。</p><h3 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h3><p>Serial：新生代单线程收集器，会暂停用户所有进程（stop the world）</p><p>Serial Old：老年代单线程收集器</p><p>ParNew：Serial 新生代多线程版本</p><p>Parallel Scavenge：新生代多线程复制算法</p><p>CMS 收集器：老年代收集器，基于标记清除算法，分为以下四个步骤：</p><ol><li>初始标记，标记 GC roots（会 stop the world）</li><li>并发标记，标记所有存活对象</li><li>重新标记，扫描新生代对象+GC Roots+被标记为“脏”区的对象（新生代在 2 时晋升到老年代对象）（会 stop the world）</li><li>并发清除</li></ol><p>G1 收集器：G1 收集器管理整个 GC 堆，作用于老年代和新生代。特点是可预测的非停顿，降低垃圾收集时间。</p><h2 id="_2-类加载过程" tabindex="-1"><a class="header-anchor" href="#_2-类加载过程" aria-hidden="true">#</a> 2 类加载过程</h2><p>JVM 类加载机制分为：加载，连接，初始化</p><p>加载：将 class 文件读入内存</p><p>连接：验证类的内部结构是否和其他类协调一致，为类变量分配内存并设置默认初始值（不是程序上的赋初始值），将对这个类的符号引用替换为直接引用（地址引用）</p><p>初始化：执行类构造器方法，也就是类变量赋值和静态代码块。</p><h2 id="_3-说说-jvm-类加载器" tabindex="-1"><a class="header-anchor" href="#_3-说说-jvm-类加载器" aria-hidden="true">#</a> 3 说说 JVM 类加载器</h2><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器：</p><ul><li><p>启动类加载器 (Bootstrap ClassLoader)：负责加载 JAVA_HOME\\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。</p></li><li><p>扩展类加载器 (Extension ClassLoader)：负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p></li><li><p>应用程序类加载器 (Application ClassLoader)：负责加载用户路径（classpath）上的类库。</p></li></ul><p>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实 现自定义的类加载器。</p><p><img src="'+o+'" alt="image-20210709103716083"></p><p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p><p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器 加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器 最终得到的都是同样一个 Object 对象。</p><h2 id="_4-说说-jvm-的分区" tabindex="-1"><a class="header-anchor" href="#_4-说说-jvm-的分区" aria-hidden="true">#</a> 4 说说 JVM 的分区</h2><p>java 内存通常被划分为 5 个区域：程序计数器（Program Count Register）、本地方法栈 （Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。</p><h2 id="_5-说说堆区分代收集设计" tabindex="-1"><a class="header-anchor" href="#_5-说说堆区分代收集设计" aria-hidden="true">#</a> 5 说说堆区分代收集设计</h2><p>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生 代又被划分成 Eden 空间、 From Survivor 和 To Survivor 三块区域。</p><p>我们把 Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。</p><p>一次 gc 发生后：</p><ol><li>Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；</li></ol><ol start="2"><li>清空 Eden 和 From Survivor ；</li><li>颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。</li></ol><p>只有在 Eden 空间快满的时候才会触发 Minor GC（新生代 GC） 。 而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p><h2 id="_6-java-虚拟机的作用" tabindex="-1"><a class="header-anchor" href="#_6-java-虚拟机的作用" aria-hidden="true">#</a> 6 Java 虚拟机的作用</h2><ol><li>解释执行字节码程序</li><li>消除平台相关性，让 Java 程序一次编译，到处运行</li></ol><h2 id="_7-gc-中如何判断对象需要被回收" tabindex="-1"><a class="header-anchor" href="#_7-gc-中如何判断对象需要被回收" aria-hidden="true">#</a> 7 GC 中如何判断对象需要被回收？</h2><p>使用可达性算法从 GC Roots 出发，标记所有未使用对象，这些对象就是有可能需要被回收对象。触发 GC 后，如果这些对象没有 finalize() 方法，就会被直接回收</p><h2 id="_8-java-虚拟机中-哪些可作为-root-对象" tabindex="-1"><a class="header-anchor" href="#_8-java-虚拟机中-哪些可作为-root-对象" aria-hidden="true">#</a> 8 JAVA 虚拟机中，哪些可作为 ROOT 对象？</h2><p>虚拟机栈中的引用对象</p><p>方法区中类静态属性引用的对象</p><p>方法区中常量引用对象</p><p>本地方法栈中 JNI 引用对象</p><h2 id="_9-jvm-内存模型是什么" tabindex="-1"><a class="header-anchor" href="#_9-jvm-内存模型是什么" aria-hidden="true">#</a> 9 JVM 内存模型是什么</h2><p>Java 内存模型 (简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从 抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存 （main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该 线程以读/写共享变量的副本。</p><p>本地内存 (工作内存) 是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其 他的硬件和编译器优化。其关系模型图如下图所示：</p><img src="'+p+'" alt="image-20210709104513251" style="zoom:80%;"><h2 id="_10-什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" tabindex="-1"><a class="header-anchor" href="#_10-什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" aria-hidden="true">#</a> 10 什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。</p><p>Java 被设计成允许应用程序可以运行在任意平台，而不需要程序员为每一个平台单独重写或者是重新编译。</p>',52),h=[d];function l(s,n){return e(),r("div",null,h)}const c=a(t,[["render",l],["__file","Java虚拟机.html.vue"]]);export{c as default};
