import{_ as e,p as n,q as a,a1 as r}from"./framework-96b046e1.js";const c={},i=r('<h2 id="_1-讲一下非公平锁和公平锁在-reetrantlock-里的实现" tabindex="-1"><a class="header-anchor" href="#_1-讲一下非公平锁和公平锁在-reetrantlock-里的实现" aria-hidden="true">#</a> 1 讲一下非公平锁和公平锁在 reetrantlock 里的实现</h2><p>非公平锁: 当线程争夺锁的过程中，会先进行一次 CAS 尝试获取锁，若失败，则进入 acquire(1) 函数，进行一次 tryAcquire 再次尝试获取锁，若再次失败，那么就通过 addWaiter 将当前线程封装成 node 结点加入到 Sync 队列，这时候该线程只能乖乖等前面的线程执行完再轮到自己了。 公平锁: 当线程在获取锁的时候，会先判断 Sync 队列中是否有在等待获取资源的线程。若没有，则尝试获取锁，若有，那么就那么就通过 addWaiter 将当前线程封装成 node 结点加入到 Sync 队列中。</p><h2 id="_2-讲一下-synchronized-可重入怎么实现" tabindex="-1"><a class="header-anchor" href="#_2-讲一下-synchronized-可重入怎么实现" aria-hidden="true">#</a> 2 讲一下 synchronized，可重入怎么实现</h2><p>通过计数器实现，每个锁关联一个线程持有者和一个计数器。</p><p>当计数器为 0 时表示该锁没有被任何线程持有， 那么任何线程都都可能获得该锁而调用相应方法。</p><p>当一个线程请求成功后，JVM 会记下持有锁的线程，并将计数器计为 1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。</p><p>当线程退出一个 synchronized 方法/ 块时，计数器会递减，如果计数器为 0 释放该锁。</p><h2 id="_3-锁和同步的区别" tabindex="-1"><a class="header-anchor" href="#_3-锁和同步的区别" aria-hidden="true">#</a> 3 锁和同步的区别</h2><p>用法上的不同：</p><p>synchronized 既可以加在方法上，也可以加载特定代码块上，而 lock 需要显示地指定起始位置和终止位置。</p><p>synchronized 是托管给 JVM 执行的，lock 的锁定是通过代码实现的，它有比 synchronized 更精确的线程语义。</p><p>性能上的不同： lock 接口的实现类 ReentrantLock，不仅具有和 synchronized 相同的并发性和内存语义， 还多了超时的获取锁、定时锁、等候和中断锁等。 在竞争不是很激烈的情况下，synchronized 的性能优于 ReentrantLock，竞争激烈的情况下 synchronized 的性能会下降的非常快，而 ReentrantLock 则基本不变。</p><p>锁机制不同： synchronized 由 JVM 自动释放锁，Lock 需要手动释放锁，容易造成死锁（synchronized 获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而 Lock 则需要开发人员手动释放，并且必须在 finally 中释放，否则会引起死锁。）</p><h2 id="_4-什么是死锁" tabindex="-1"><a class="header-anchor" href="#_4-什么是死锁" aria-hidden="true">#</a> 4 什么是死锁</h2><p>多个线程互相等待其他线程释放资源，陷入无限等待，就是死锁。</p><h3 id="_5-如何确保-n-个线程可以访问-n-个资源同时又不导致死" tabindex="-1"><a class="header-anchor" href="#_5-如何确保-n-个线程可以访问-n-个资源同时又不导致死" aria-hidden="true">#</a> 5 如何确保 N 个线程可以访问 N 个资源同时又不导致死</h3><p>破坏死锁条件（互斥条件不可破坏）：</p><ol><li>破坏请求和保持条件：允许程序初期获取所有资源再开始运行</li><li>破坏不可抢占条件：申请不到资源时，一次性释放所有资源</li><li>破坏循环等待条件：按序申请资源，例如资源 ABCD，每个线程都按 ABCD 顺序申请</li></ol>',18),d=[i];function h(o,t){return n(),a("div",null,d)}const l=e(c,[["render",h],["__file","Java锁.html.vue"]]);export{l as default};
