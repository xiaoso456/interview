import{_ as a,p as e,q as r,a1 as i}from"./framework-96b046e1.js";const t="/interview/assets/image-20230127175220894-6bad465b.png",p="/interview/assets/image-20230127184552594-0c255e56.png",d={},h=i('<h2 id="_1-面向对象特性" tabindex="-1"><a class="header-anchor" href="#_1-面向对象特性" aria-hidden="true">#</a> 1 面向对象特性</h2><p>抽象、封装、继承、多态</p><p>抽象：抽出共同特征</p><p>封装：对扩展开放，对修改关闭</p><p>继承：允许和鼓励类的重用</p><p>多态：指允许不同类的对象对同一消息做出响应</p><p>Java 表现为编译时多态和运行时多态。编译时多态为同名方法具有不参数，运行时多态为子类重写父类方法。</p><h2 id="_2-类和对象的区别" tabindex="-1"><a class="header-anchor" href="#_2-类和对象的区别" aria-hidden="true">#</a> 2 类和对象的区别</h2><p>类是对一类事物的描述，是对象的集合体</p><p>对象是类的实例化</p><h2 id="_3-请列举你所知道的-object-类的方法" tabindex="-1"><a class="header-anchor" href="#_3-请列举你所知道的-object-类的方法" aria-hidden="true">#</a> 3 请列举你所知道的 Object 类的方法</h2><p>clone() 创建并返回此对象的一个副本。需要类 implements Cloneable 接口，如果不重写 clone 方法，实现 Cloneable 仅仅起到标记作用，clone 是一个 native 方法，由 jvm 实现。</p><p>equals(Object obj) 指 示某个其他对象是否与此对象“相等”。</p><p>finalize() 当垃圾回收器确定不存在对该对象的更多引 用时，由对象的垃圾回收器调用此方法。</p><p>getClass() 返回一个对象的运行时类。</p><p>hashCode() 返回 该对象的哈希码值。</p><p>notify() 唤醒在此对象监视器上等待的单个线程。</p><p>notifyAll() 唤醒在此 对象监视器上等待的所有线程。</p><p>toString() 返回该对象的字符串表示。</p><p>wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p><h2 id="_4-重载和重写的区别-相同参数不同返回值能重载吗" tabindex="-1"><a class="header-anchor" href="#_4-重载和重写的区别-相同参数不同返回值能重载吗" aria-hidden="true">#</a> 4 重载和重写的区别？相同参数不同返回值能重载吗？</h2><p>重载（Overloading） ：同名函数具有不同参数列表</p><p>重写（Overriding）：利用多态性，子类覆盖父类方法。需要参数列表一致、子类方法访问权限&gt;=父类（例如子类 public，父类 protected）、返回类型为父类返回类型的派生类。</p><p><img src="'+t+'" alt="image-20230127175220894"></p><p>可不记扩展：</p><p>方法重写的规则</p><ol><li>参数列表与被重写方法的参数列表必须完全一致。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>父类的成员方法只能被它的子类重写。</li><li>被 final 修饰的方法不能被重写。</li><li>被 static 修饰的，即静态方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了访问权限是 private 和 被 final 修饰 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造器不能被重写。</li><li>如果不能继承一个类，则不能重写该类的方法。</li></ol><h2 id="_5-static-关键字是什么意思-java-中是否可以覆盖-override-一个-private-或者是-static-的方法" tabindex="-1"><a class="header-anchor" href="#_5-static-关键字是什么意思-java-中是否可以覆盖-override-一个-private-或者是-static-的方法" aria-hidden="true">#</a> 5 ”static”关键字是什么意思？Java 中是否可以覆盖 (override) 一个 private 或者是 static 的方法？</h2><p>static 表示方法或变量是静态的</p><p>static 方法不能被覆盖，因为覆盖是运行时绑定，static 方法是编译时绑定，但是 static 方法能够被再次声明。</p><p>private 方法不可以 override，因为子类不能访问父类 private 方法</p><h2 id="_6-stringbuffer-和-stringbuilder-有什么区别-底层实现上呢" tabindex="-1"><a class="header-anchor" href="#_6-stringbuffer-和-stringbuilder-有什么区别-底层实现上呢" aria-hidden="true">#</a> 6 StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？</h2><p>StringBuffer 线程安全，StringBuilder 线程不安全</p><p>底层实现上的话，StringBuffer 其 实就是比 StringBuilder 多了 Synchronized 修饰符</p><h2 id="_7-类加载机制-双亲委派模型-好处是什么" tabindex="-1"><a class="header-anchor" href="#_7-类加载机制-双亲委派模型-好处是什么" aria-hidden="true">#</a> 7 类加载机制，双亲委派模型，好处是什么？</h2><p>特定类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归， 如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，例如 Stirng 类无论在哪个类加载器加载，始终会交给最顶层 Bootstrap ClassLoader 进行加载，防止同名类由不通加载器加载造成混乱。</p><h2 id="_8-静态变量存放在哪" tabindex="-1"><a class="header-anchor" href="#_8-静态变量存放在哪" aria-hidden="true">#</a> 8 静态变量存放在哪？</h2><p>Jdk8 以前是方法区，因为之前是用永久代来保存类信息的。</p><p>Jdk8 将这些分在元空间（直接内存）和堆中。堆里面存储了静态变量和常量。元空间存储的是类的元信息（主要是类型信息如类名、访问修饰符、字段描述、方法描述等。）</p><h2 id="_9-什么是泛型" tabindex="-1"><a class="header-anchor" href="#_9-什么是泛型" aria-hidden="true">#</a> 9 什么是泛型？</h2><p>泛型，即“参数化类型”，把类型作为参数传入。</p><h2 id="_10-解释-extends-和-super-泛型限定符-上界不存下界不取" tabindex="-1"><a class="header-anchor" href="#_10-解释-extends-和-super-泛型限定符-上界不存下界不取" aria-hidden="true">#</a> 10 解释 extends 和 super 泛型限定符-上界不存下界不取</h2><p>编译器可以支持向上转型，但不支持向下转型。</p><p><code>&lt;? extends T&gt;</code>：是指 “上界通配符”，存入时，不知道如何转型（只有 T 接得住）</p><p><code>&lt;? super T&gt;</code>：是指 “下界通配符”，取出时，不知道如何转型（只有 Object 接的住）</p><h2 id="_11-谈谈如何通过反射创建对象" tabindex="-1"><a class="header-anchor" href="#_11-谈谈如何通过反射创建对象" aria-hidden="true">#</a> 11 谈谈如何通过反射创建对象？</h2><p>方法 1：通过类对象调用 newInstance() 方法，例如：String.class.newInstance() -</p><p>方法 2：通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器 （Constructor）对象并调用其 newInstance() 方法创建对象，例如： String.class.getConstructor(String.class).newInstance(&quot;Hello&quot;);</p><h2 id="_12-java-支持多继承吗" tabindex="-1"><a class="header-anchor" href="#_12-java-支持多继承吗" aria-hidden="true">#</a> 12 Java 支持多继承吗？</h2><p>不支持，但 Java 接口可以多继承，一个子接口可以有多个父接口。</p><h2 id="_13-接口和抽象类的区别是什么" tabindex="-1"><a class="header-anchor" href="#_13-接口和抽象类的区别是什么" aria-hidden="true">#</a> 13 接口和抽象类的区别是什么？</h2><p>接口所有方法都是抽象的，抽象类可以同时包含抽象和非抽象方法。</p><p>类可以有很多个接口，但只能继承一个抽象类。</p><p>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。</p><p>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者 是 public。</p><h2 id="_14-comparable-和-comparator-接口是干什么的-列出它们的区别" tabindex="-1"><a class="header-anchor" href="#_14-comparable-和-comparator-接口是干什么的-列出它们的区别" aria-hidden="true">#</a> 14 Comparable 和 Comparator 接口是干什么的？列出它们的区别</h2><p>Comparable 只包含一个函数 compareTo()，用于该类内部排序</p><p>Comparator 是一个外部比较器，指导类如何排序，包含 compare() 和 equals()。</p><h2 id="_15-静态内部类和内部类的区别" tabindex="-1"><a class="header-anchor" href="#_15-静态内部类和内部类的区别" aria-hidden="true">#</a> 15 静态内部类和内部类的区别</h2><p>内部类需要在外部类实例化之后才能被实例化，可以直接访问外部类成员变量</p><p>静态内部类不能访问外部类静态成员</p><h2 id="_16-java-异常类" tabindex="-1"><a class="header-anchor" href="#_16-java-异常类" aria-hidden="true">#</a> 16 Java 异常类</h2><p><img src="'+p+'" alt="image-20230127184552594"></p><p>Error 是编译时错误和系统错误</p><p>Error 和 Exception 都继承自 Throwable</p><p>Exception 分为受检查异常和非运行时异常，受检查异常要求编译时通过 throws 抛出或 try-catch 处理</p><h2 id="_17-如何通过反射获取和设置对象私有字段的值" tabindex="-1"><a class="header-anchor" href="#_17-如何通过反射获取和设置对象私有字段的值" aria-hidden="true">#</a> 17 如何通过反射获取和设置对象私有字段的值？</h2><p>可以通过类对象的 getDeclaredField() 方法字段（Field）对象，然后再通过字段对象的 setAccessible(true) 将其设置为可以访问，接下来就可以通过 get/set 方法来获取/设置字段的值了。</p><h2 id="_18-谈一下面向对象的-六原则一法则" tabindex="-1"><a class="header-anchor" href="#_18-谈一下面向对象的-六原则一法则" aria-hidden="true">#</a> 18 谈一下面向对象的&quot;六原则一法则&quot;</h2><p>单一职责原则：一个类只做它该做的事情。</p><p>开闭原则：对扩展开放， 对修改关闭。(要加功能，派生新类)</p><p>依赖倒转原则：面向接口编程，应该使用接口而不是实体类。</p><p>里氏替换原则：任何时候都可以用子类型替换掉父类型。</p><p>合成聚合复用原则：优先使用聚合或合成关系复用代码。（就是用组合，用 Has 而不是继承）</p><p>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</p><h2 id="_19-hashcode-和-equals-方法有什么联系" tabindex="-1"><a class="header-anchor" href="#_19-hashcode-和-equals-方法有什么联系" aria-hidden="true">#</a> 19 hashCode() 和 equals() 方法有什么联系？</h2><p>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：</p><p>➀ 相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p><p>➁ 如果两个对象的 hashCode 相同，它们并不一定相同。</p>',80),n=[h];function s(c,o){return e(),r("div",null,n)}const _=a(d,[["render",s],["__file","Java面向对象.html.vue"]]);export{_ as default};
