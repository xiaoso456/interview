import{_ as e,p as a,q as i,a1 as d}from"./framework-96b046e1.js";const r="/interview/assets/image-20230226203443303-8423c35e.png",t="/interview/assets/watermark_image_d2F0ZXIvYmFpa2U5Mg___g_7_xp_5_yp_5-9acfcf9b.png",l={},s=d('<h2 id="_1-mysql-主从复制的过程" tabindex="-1"><a class="header-anchor" href="#_1-mysql-主从复制的过程" aria-hidden="true">#</a> 1 mysql 主从复制的过程</h2><div class="custom-container tip"><p class="custom-container-title">提示</p><p>bin log（二进制日记）：记录DDL和DML，不记录查询</p><p>relay log（中继日记）：包含待执行的语句</p></div><ol><li>主库将数据更改斜日 bin log 日志</li><li>从库通过I/O线程读取主数据库bin log日志</li><li>从库通过将bin log拷贝到 relay log中</li><li>从库重做 relay log，完成数据同步</li></ol><h2 id="_2-怎么能解决脏读问题" tabindex="-1"><a class="header-anchor" href="#_2-怎么能解决脏读问题" aria-hidden="true">#</a> 2 怎么能解决脏读问题？</h2><p>脏读问题的解决方法有：</p><ol><li>乐观锁：获取数据指定数据的版本号，修改时对版本号检查。</li><li>悲观锁：每次获取数据前，都会对该数据加锁，使得任何其他线程都无法获取该数据。</li><li>数据库隔离级别：使用可重复读或以上的数据库隔离级别。</li></ol><h2 id="_3-redis是怎么标记失效的" tabindex="-1"><a class="header-anchor" href="#_3-redis是怎么标记失效的" aria-hidden="true">#</a> 3 redis是怎么标记失效的</h2><p>Redis使用key的设置超时来标记key失效，可以用 expire 命令设置</p><p>Redis也有自己的数据淘汰策略，超过内存时触发</p><h2 id="_4-redis失效你怎么设计" tabindex="-1"><a class="header-anchor" href="#_4-redis失效你怎么设计" aria-hidden="true">#</a> 4 redis失效你怎么设计</h2><p>对于热点数据，为了防止雪崩，一般不设置过期时间</p><p>选择合适的淘汰策略，可以根据过期时间、最少使用两个维度或者随机淘汰，一般是使用最少使用的进行淘汰</p><h2 id="_5-红黑树-b树-b-树区别" tabindex="-1"><a class="header-anchor" href="#_5-红黑树-b树-b-树区别" aria-hidden="true">#</a> 5 红黑树，b树，b+树区别</h2><p>红黑树是自平衡的二叉树，b树和b+树是多叉树。</p><p>b树和b+树：b+树非叶子节点不保存数据，只保存索引，查询效率稳定，节点有指向下一节点的指针，便于范围查询。</p><h2 id="_6-怎么保证redis-mysql一致性-双写一致性" tabindex="-1"><a class="header-anchor" href="#_6-怎么保证redis-mysql一致性-双写一致性" aria-hidden="true">#</a> 6 怎么保证redis/mysql一致性（双写一致性）</h2><p>最终一致性：</p><ol><li><p>使用事务保证双写同时成功或失败。一般先写 mysql，在写redis</p></li><li><p>可以只写mysql，然后用定时任务或者监听binlog日志，让redis数据和mysql同步</p></li><li><p>如果是删除可以考虑写mysql，再删redis（失败了重试）</p></li></ol><h2 id="_7-数据库的隔离级别有哪几个" tabindex="-1"><a class="header-anchor" href="#_7-数据库的隔离级别有哪几个" aria-hidden="true">#</a> 7 数据库的隔离级别有哪几个？</h2><p>4个：未提交读、已提交读、可重复读、可串行化</p><p>可以深读一下以下内容：</p><table><thead><tr><th>隔离级别</th><th>读脏数据</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>未提交读(Read Uncommitted)：允许脏读，也就是可能<strong>读取到其他会话中未提交事务修改的数据</strong>。</p><p>提交读(Read Committed)：只能读取到已经提交事务的数据。Oracle 等多数数据库默认都是该 级别 (不重复读)。</p><p>可重复读(Repeated Read)：可重复读。在同一个事务多个实例并发查询都是事务开始时刻一致的（会看到同样的数据），InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p><p>读脏数据：读到其他会话事务未提交事务的数据。【通俗：读到了别的事务回滚前的脏数据】</p><p>不可重复读【重点在update和delete，同一事务重复读同一数据就会出现问题，行锁可以解决，但解决不了insert幻读问题】：读到其他会话事务提交的数据【当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配】</p><p>幻读【重点在insert】：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读</p><p>值得注意的是mysql可重复读级别解决了幻读</p><p>MVCC多版本并发控制</p><p><img src="'+r+'" alt="image-20230226203443303"></p><h2 id="_8-sql慢了什么原因怎么查" tabindex="-1"><a class="header-anchor" href="#_8-sql慢了什么原因怎么查" aria-hidden="true">#</a> 8 sql慢了什么原因怎么查</h2><p>启动慢sql日志，然后可以去定位和优化sql，找到sql语句后使用 expain 语句查看 sql 执行计划。</p><h2 id="_9-mvcc怎么实现的-其原理是什么" tabindex="-1"><a class="header-anchor" href="#_9-mvcc怎么实现的-其原理是什么" aria-hidden="true">#</a> 9 mvcc怎么实现的，其原理是什么</h2><p>mysql 的mvcc 是通过添加两个隐藏列，记录创建和删除版本号实现的，每次事务操作都会给全局版本号+1。查询时，只会查询比自身版本号小的，使得绝大多数操作不用加锁</p><h2 id="_10-什么情况用redis什么情况用mysql" tabindex="-1"><a class="header-anchor" href="#_10-什么情况用redis什么情况用mysql" aria-hidden="true">#</a> 10 什么情况用redis什么情况用mysql？</h2><p>mysql适合并发较低，数据要求可靠性高的</p><p>redis适合并发高，数据可靠性较低的</p><h2 id="_11-b-树什么样子为什么能实现范围查找" tabindex="-1"><a class="header-anchor" href="#_11-b-树什么样子为什么能实现范围查找" aria-hidden="true">#</a> 11 b+树什么样子为什么能实现范围查找</h2><p>B+树叶子节点之间用指针连接，形成类似单链表的结构，适合范围查找</p><h2 id="_12-select是事务的么" tabindex="-1"><a class="header-anchor" href="#_12-select是事务的么" aria-hidden="true">#</a> 12 select是事务的么</h2><p>如果开启了自动提交事务，每一条sql语句都会开启事务</p><h2 id="_13-聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_13-聚簇索引和非聚簇索引" aria-hidden="true">#</a> 13 聚簇索引和非聚簇索引</h2><p>聚簇索引：叶子节点存储的是完整行数据</p><p>非聚簇索引（二级索引）：叶子节点存的是数据的位置</p><p>覆盖索引：叶子节点存储完整行数据</p><h2 id="_14-redis都有什么数据结构" tabindex="-1"><a class="header-anchor" href="#_14-redis都有什么数据结构" aria-hidden="true">#</a> 14 redis都有什么数据结构？</h2><ul><li>字符串（String）</li><li>散列（Hash）</li><li>列表（List）</li><li>集合（Set）</li><li>有序集合（Sorted set）</li></ul><h2 id="_15-zset怎么实现的" tabindex="-1"><a class="header-anchor" href="#_15-zset怎么实现的" aria-hidden="true">#</a> 15 zset怎么实现的?</h2><p>一个String类型的field和一个double类型的score组成的</p><p>基于跳表实现</p><h2 id="_16-跳表是什么" tabindex="-1"><a class="header-anchor" href="#_16-跳表是什么" aria-hidden="true">#</a> 16 跳表是什么？</h2><p>跳表是一种用于快速查找的数据结构，查找有两个动作：</p><ul><li>如果被查找值比链表下一节点值大，则移动到下一节点</li><li>如果被查找值比链表下一节点值大，则移动到下一链表</li></ul><p><img src="'+t+'" alt="img"></p><h2 id="_17-binlog-redolog-undolog作用和区别" tabindex="-1"><a class="header-anchor" href="#_17-binlog-redolog-undolog作用和区别" aria-hidden="true">#</a> 17 Binlog,redolog, undolog作用和区别</h2><p>binlog是逻辑日志，记录sql，一般用于备份，保证数据的持久化</p><p>redolog是物理日志，记录事务信息，一般用于数据恢复</p><p>undolog用于回滚，保证事务的原子性，用于撤销操作</p><h2 id="_18-为什么要刷盘到redolog而不直接写入磁盘" tabindex="-1"><a class="header-anchor" href="#_18-为什么要刷盘到redolog而不直接写入磁盘" aria-hidden="true">#</a> 18 为什么要刷盘到redolog而不直接写入磁盘？</h2><p>redo log相当于缓冲区，减少响应时间，可以提高性能。</p><p>只有事务提交了后才会直接写到磁盘，保证事务原子性</p><h2 id="_19-mysql锁知道意向锁么" tabindex="-1"><a class="header-anchor" href="#_19-mysql锁知道意向锁么" aria-hidden="true">#</a> 19 mysql锁知道意向锁么？</h2><p>意向锁是为了简化对其他事务获取锁时的判断，是针对表的锁，表明事务意图对行上锁。允许行级锁和表级锁共存</p><h2 id="_20-redis持久化-rdb和aof原理" tabindex="-1"><a class="header-anchor" href="#_20-redis持久化-rdb和aof原理" aria-hidden="true">#</a> 20 Redis持久化，RDB和AOF原理？</h2><p>RDB：保存 Redis 中所有数据快照，会fork一个进程写入当前数据到临时文件，然后替换上次的快照文件。特点是还原快</p><p>AOF：保存Redis执行的write命令，能最大限度保持数据完整。</p><p>也可以使用混合持久化</p><h2 id="_21-left-join和exists的区别和适用场景" tabindex="-1"><a class="header-anchor" href="#_21-left-join和exists的区别和适用场景" aria-hidden="true">#</a> 21 left join和exists的区别和适用场景</h2><p>left join 适用于需要返回作表所有记录且使用右表关联字段</p><p>exists 适用于判断左表记录是否关联到右表记录，不返回右表字段值</p><h2 id="_22-left-join和inner-join区别" tabindex="-1"><a class="header-anchor" href="#_22-left-join和inner-join区别" aria-hidden="true">#</a> 22 left join和inner join区别</h2>',73),h=[s];function n(p,o){return a(),i("div",null,h)}const _=e(l,[["render",n],["__file","数据库.html.vue"]]);export{_ as default};
