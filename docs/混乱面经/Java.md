## 1 多线程是怎么实现的？

继承Thread类或实现Runnable接口

## 2 读写锁和互斥锁的区别

读写锁区分读锁和写锁，上了读锁后仍然可以上读锁，适合多读少写常见。

## 3 进程通信、线程通信方式有哪些？

进程通信：共享内存、信号量、消息队列、管道、socket

线程通信：锁、wait-notify、synchronized

## 4 hashmap是什么样的，怎么保证线程安全？

hashmap 是散列表，底层用数组实现。保证线程安全可以使用ConcurrentHashMap

## 5 lambda表达式是什么？

也可以叫做匿名函数，帮助快速定义函数

## 6 jdk1.7和1.8区别

lambda、新的时间日期类、optional判空

## 7 Java锁和底层原理

Java锁常用的有synchronized和ReentrantLock关键字

synchronized在jvm中有偏向锁、轻量级锁、重量级锁几种状态

说说锁升级过程：

线程获取锁时，会先获取对象头线程信息

如果没有，会把这个信息设置为当前线程id，表示偏向锁

如果有，会检查是否和自身线程id相同，不相同会尝试把线程id修改为自己的，升级为轻量级锁

如果修改失败，说明当前存在竞争，可能会升级为重量级锁

## 8 说说 volatile

+ 禁止指令重排，有序
+ 可以绕开java内存模型中线程缓存，操作变量时强制从主内存中读写



## 9 hashmap的底层结构？

底层是数组，存储时用散列的方式把key映射到不同的 bucket 中

如果冲突，会在冲突的位置形成链表，大于等于8时，会把链表转化为红黑树

## 10 什么是 happen before 原则？

happens-before关系的定义如下：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. **两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。**